data <- panels[[1]]
metadata_list <- list()
for(x in 1:length(panels)){
if(x != 1){
data <- merge(data, panels[[x]], merge.dr = "pca")
}
metadata_list <- append(metadata_list, rep(names(panels)[x], ncol(panels[[x]])))
}
data$celltype <- metadata_list
harmonizedData <- data %>%
RunHarmony.Seurat(group.by = "celltype", plot_convergence = TRUE, reduction = "pca")
x
data$celltype[1600]
p1 <- DimPlot(object = harmonizedData, reduction = "harmony", pt.size = .1, group.by = "celltype")
?unique
metadata_list
data$celltype[1600]
data$celltype[1656]
metadata_list[1656]
data <- panels[[1]]
metadata_list <- list()
for(x in 1:length(panels)){
if(x != 1){
data <- merge(data, panels[[x]], merge.dr = "pca")
}
append(metadata_list, rep(names(panels)[x], ncol(panels[[x]])))
}
data$celltype <- metadata_list
metadata_list
length(metadata_list)
append(metadata_list, rep(names(panels)[1], ncol(panels[[1]])))
rep(names(panels)[x], ncol(panels[[x]]))
rep(names(panels)[1], ncol(panels[[1]]))
data <- panels[[1]]
metadata_list <- list()
for(x in 1:length(panels)){
if(x != 1){
data <- merge(data, panels[[x]], merge.dr = "pca")
}
metadata_list <- c(metadata_list, rep(names(panels)[x], ncol(panels[[x]])))
}
data$celltype <- metadata_list
harmonizedData <- data %>%
RunHarmony.Seurat(group.by = "celltype", plot_convergence = TRUE, reduction = "pca")
metadata_list
metadata_list[1]
p1 <- DimPlot(object = harmonizedData, reduction = "harmony", pt.size = .1, group.by = "celltype")
data <- panels[[1]]
metadata_list <- list()
for(x in 1:length(panels)){
if(x != 1){
data <- merge(data, panels[[x]], merge.dr = "pca")
}
# metadata_list <- c(metadata_list, rep(names(panels)[x], ncol(panels[[x]])))
}
metadata_list <- c(metadata_list, rep("jurkrat"), 400)
browser()
metadata_list
data$celltype <- metadata_list
data <- panels[[1]]
metadata_list <- list()
for(x in 1:length(panels)){
if(x != 1){
data <- merge(data, panels[[x]], merge.dr = "pca")
}
# metadata_list <- c(metadata_list, rep(names(panels)[x], ncol(panels[[x]])))
}
metadata_list <- c(metadata_list, rep("jurkrat", 400))
browser()
metadata_list
data$celltype <- metadata_list
length(panels[[1]])
length(panels[1])
ncol(panels[1])
ncol(panels[[1])
ncol(panels[[1]])
data <- panels[[1]]
metadata_list <- list()
for(x in 1:length(panels)){
if(x != 1){
data <- merge(data, panels[[x]], merge.dr = "pca")
}
for(y in 1:ncol(panels[[x]]))
metadata_list <- append(metadata_list, names(panels)[y])
#metadata_list <- c(metadata_list, rep(names(panels)[x], ncol(panels[[x]])))
}
metadata_list <- c(metadata_list, rep("jurkrat", 400))
browser()
metadata_list
data$celltype <- metadata_list
data <- panels[[1]]
metadata_list <- list()
for(x in 1:length(panels)){
if(x != 1){
data <- merge(data, panels[[x]], merge.dr = "pca")
}
for(y in 1:ncol(panels[[x]]))
metadata_list <- append(metadata_list, names(panels)[y])
browser()
#metadata_list <- c(metadata_list, rep(names(panels)[x], ncol(panels[[x]])))
}
metadata_list
metadata_list <- c(metadata_list, rep("jurkrat", 400))
browser()
metadata_list
metadata_list[1]
metadata_list[1000]
metadata_list[500]
data$celltype <- metadata_list
data <- panels[[1]]
metadata_list <- list()
for(x in 1:length(panels)){
if(x != 1){
data <- merge(data, panels[[x]], merge.dr = "pca")
}
for(y in 1:ncol(panels[[x]]))
metadata_list <- append(metadata_list, names(panels)[x])
browser()
#metadata_list <- c(metadata_list, rep(names(panels)[x], ncol(panels[[x]])))
}
x
nrow(metadata_list)
length(metadata_list)
c(rep("MEL", ncol(MEL)), rep("HNSCC", ncol(HNSCC)))
metadata_list <- c(metadata_list, rep("jurkrat", 400))
browser()
data$celltype <- metadata_list
nrow[panels[1:3]]
nrow[panels[2]]
nrow(panels[1:3])
nrow(panels[1])
nrow(panels[[1:3]])
nrow(panels[[1]])
ncol(panels[[1]])
ncol(panels[[1:3]])
ncol(panels[[2]])
ncol(panels[[3]])
data <- panels[[1]]
metadata_list <- list()
for(x in 1:length(panels)){
if(x != 1){
data <- merge(data, panels[[x]], merge.dr = "pca")
}
# for(y in 1:ncol(panels[[x]]))
#   metadata_list <- append(metadata_list, names(panels)[x])
# browser()
#metadata_list <- c(metadata_list, rep(names(panels)[x], ncol(panels[[x]])))
}
metadata_list <- c(rep("jurkrat", 478), rep("t293", 589), rep("5050", 589))
browser()
data$celltype <- metadata_list
harmonizedData <- data %>%
RunHarmony.Seurat(group.by = "celltype", plot_convergence = TRUE, reduction = "pca")
data <- panels[[1]]
metadata_list <- list()
for(x in 1:length(panels)){
if(x != 1){
data <- merge(data, panels[[x]], merge.dr = "pca")
}
# for(y in 1:ncol(panels[[x]]))
#   metadata_list <- append(metadata_list, names(panels)[x])
# browser()
#metadata_list <- c(metadata_list, rep(names(panels)[x], ncol(panels[[x]])))
}
metadata_list <- c(rep("jurkrat", 478), rep("t293", 589), rep("5050", 589))
browser()
data$celltype <- metadata_list
harmonizedData <- data %>%
RunHarmony(group.by = "celltype", plot_convergence = TRUE, reduction = "pca")
?harmony
data <- panels[[1]]
metadata_list <- list()
for(x in 1:length(panels)){
if(x != 1){
data <- merge(data, panels[[x]], merge.dr = "pca")
}
# for(y in 1:ncol(panels[[x]]))
#   metadata_list <- append(metadata_list, names(panels)[x])
# browser()
#metadata_list <- c(metadata_list, rep(names(panels)[x], ncol(panels[[x]])))
}
metadata_list <- c(rep("jurkrat", 478), rep("t293", 589), rep("5050", 589))
browser()
data$celltype <- metadata_list
harmonizedData <- data %>%
RunHarmony(group.by = "celltype", plot_convergence = TRUE, reduction = "pca")
# onehot <- function(x) {
#     browser()
#     res <- model.matrix(~0 + x)
#     colnames(res) <- gsub('^x(.*)', '\\1', colnames(res))
#     return(res)
# }
# HarmonyMatrix <- function(
#     data_mat, meta_data, vars_use, do_pca = TRUE,
#     npcs = 20, theta = NULL, lambda = NULL, sigma = 0.1,
#     nclust = NULL, tau = 0, block.size = 0.05,
#     max.iter.harmony = 10, max.iter.cluster = 200,
#     epsilon.cluster = 1e-5, epsilon.harmony = 1e-4,
#     plot_convergence = FALSE, return_object = FALSE,
#     verbose = TRUE, reference_values = NULL, cluster_prior = NULL
# ) {
#
#
#     ## TODO: check for
#     ##    partially observed batch variables (WARNING)
#     ##    batch variables with only 1 level (WARNING)
#     ##    if lambda given, check correct length
#     ##    if theta given, check correct length
#     ##    very small batch size and tau=0: suggest tau>0
#     ##    is PCA correct?
#     if (!(is(meta_data, 'data.frame') | is(meta_data, 'DataFrame'))) {
# #     if (!c('data.frame', '') %in% class(meta_data)) {
#         if (length(meta_data) %in% dim(data_mat)) {
#             meta_data <- data.frame(batch_variable = meta_data)
#             vars_use <- 'batch_variable'
#         } else {
#             stop('meta_data must be either a data.frame or a vector with batch
#                 values for each cell')
#         }
#     }
#
#     if (is.null(vars_use) | any(!vars_use %in% colnames(meta_data))) {
#         msg <- gettextf('must provide variables names (e.g. vars_use=%s)',
#                         sQuote('stim'))
#         stop(msg)
#     }
#
#     if (do_pca) {
#         if (ncol(data_mat) != nrow(meta_data)) {
#             data_mat <- Matrix::t(data_mat)
#         }
#
#         pca_res <- data_mat %>%
#             scaleData() %>%
#             irlba::prcomp_irlba(n = npcs, retx = TRUE, center = FALSE,
#                                 scale. = FALSE)
#         data_mat <- pca_res$rotation %*% diag(pca_res$sdev)
#     }
#
#     N <- nrow(meta_data)
#     cells_as_cols <- TRUE
#     if (ncol(data_mat) != N) {
#         if (nrow(data_mat) == N) {
#             data_mat <- t(data_mat)
#             cells_as_cols <- FALSE
#         } else {
#             stop("number of labels do not correspond to number of
#                 samples in data matrix")
#         }
#     }
#
#     if (is.null(nclust)) {
#         nclust <- min(round(N / 30), 100)
#     }
#     if (is.null(theta)) {
#         theta <- rep(2, length(vars_use))
#     } else if (length(theta) != length(vars_use)) {
#         stop('Please specify theta for each variable')
#     }
#     if (is.null(lambda)) {
#         lambda <- rep(1, length(vars_use))
#     } else if (length(lambda) != length(vars_use)) {
#         stop('Please specify lambda for each variable')
#     }
#     if (length(sigma) == 1 & nclust > 1) {
#         sigma <- rep(sigma, nclust)
#     }
#     browser()
#     ## Pre-compute some useful statistics
#     phi <- Reduce(rbind, lapply(vars_use, function(var_use) {
#         t(onehot(meta_data[[var_use]]))
#     }))
#     N_b <- rowSums(phi)
#     Pr_b <- N_b / N
#     B_vec <- Reduce(c, lapply(vars_use, function(var_use) {
#         length(unique(meta_data[[var_use]]))
#     }))
#     theta <- Reduce(c, lapply(seq_len(length(B_vec)), function(b)
#         rep(theta[b], B_vec[b])))
#     theta <- theta * (1 - exp(-(N_b / (nclust * tau)) ^ 2))
#
#     lambda <- Reduce(c, lapply(seq_len(length(B_vec)), function(b)
#         rep(lambda[b], B_vec[b])))
#     lambda_mat <- diag(c(0, lambda))
#
#     ## TODO: check that each ref val matches exactly one covariate
#     ## TODO: check that you haven't marked all cells as reference!
#     if (!is.null(reference_values)) {
#         idx <- which(row.names(phi) %in% reference_values)
#         cells_ref <- which(colSums(phi[idx, , drop = FALSE] == 1) >= 1)
#         b_keep <- which(!row.names(phi) %in% reference_values)
#         phi_moe <- phi[b_keep, , drop = FALSE]
#         phi_moe[, cells_ref] <- 0
#
#         phi_moe <- rbind(rep(1, N), phi_moe)
#         lambda_mat <- lambda_mat[c(1, b_keep + 1), c(1, b_keep + 1)]
#     } else {
#         phi_moe <- rbind(rep(1, N), phi)
#     }
#
#     ## RUN HARMONY
#     harmonyObj <- new(harmony, 0) ## 0 is a dummy variable - will change later
#     harmonyObj$setup(
#         data_mat, phi, phi_moe,
#         Pr_b, sigma, theta, max.iter.cluster,epsilon.cluster,
#         epsilon.harmony, nclust, tau, block.size, lambda_mat, verbose
#     )
#     init_cluster(harmonyObj, cluster_prior)
#     harmonize(harmonyObj, max.iter.harmony, verbose)
#     if (plot_convergence) graphics::plot(HarmonyConvergencePlot(harmonyObj))
#
#     ## Return either the R6 Harmony object or the corrected PCA matrix
#     if (return_object) {
#         return(harmonyObj)
#     } else {
#         res <- as.matrix(harmonyObj$Z_corr)
#         row.names(res) <- row.names(data_mat)
#         colnames(res) <- colnames(data_mat)
#         if (!cells_as_cols)
#             res <- t(res)
#         return(res)
#     }
# }
# ```
#
#
# ```{r}
# RunHarmony.Seurat <- function(
#   object,
#   group.by.vars,
#   reduction = 'pca',
#   dims.use = NULL,
#   theta = NULL,
#   lambda = NULL,
#   sigma = 0.1,
#   nclust = NULL,
#   tau = 0,
#   block.size = 0.05,
#   max.iter.harmony = 10,
#   max.iter.cluster = 20,
#   epsilon.cluster = 1e-5,
#   epsilon.harmony = 1e-4,
#   plot_convergence = FALSE,
#   verbose = TRUE,
#   reference_values = NULL,
#   reduction.save = "harmony",
#   assay.use = NULL,
#   project.dim = TRUE,
#   ...
# ) {
#   if (!requireNamespace('Seurat', quietly = TRUE)) {
#     stop("Running Harmony on a Seurat object requires Seurat")
#   }
#   assay.use <- assay.use %||% Seurat::DefaultAssay(object)
#   if (reduction == "pca" && !reduction %in% Seurat::Reductions(object = object)) {
#     if (isTRUE(x = verbose)) {
#       message("Harmony needs PCA. Trying to run PCA now.")
#     }
#     object <- tryCatch(
#       expr = Seurat::RunPCA(
#         object = object,
#         assay = assay.use,
#         verbose = verbose,
#         reduction.name = reduction
#       ),
#       error = function(...) {
#         stop("Harmony needs PCA. Tried to run PCA and failed.")
#       }
#     )
#   }
#   if (!reduction %in% Seurat::Reductions(object = object)) {
#     stop("Requested dimension reduction is not present in the Seurat object")
#   }
#   embedding <- Seurat::Embeddings(object, reduction = reduction)
#   if (is.null(dims.use)) {
#     dims.use <- seq_len(ncol(embedding))
#   }
#   dims_avail <- seq_len(ncol(embedding))
#   if (!all(dims.use %in% dims_avail)) {
#     stop("trying to use more dimensions than computed. Rereun dimension reduction
#          with more dimensions or run Harmony with fewer dimensions")
#   }
#   if (length(dims.use) == 1) {
#     stop("only specified one dimension in dims.use")
#   }
#   metavars_df <- Seurat::FetchData(
#     object,
#     group.by.vars,
#     cells = Seurat::Cells(x = object[[reduction]])
#   )
#
#   harmonyEmbed <- HarmonyMatrix(
#     embedding,
#     metavars_df,
#     group.by.vars,
#     FALSE,
#     0,
#     theta,
#     lambda,
#     sigma,
#     nclust,
#     tau,
#     block.size,
#     max.iter.harmony,
#     max.iter.cluster,
#     epsilon.cluster,
#     epsilon.harmony,
#     plot_convergence,
#     FALSE,
#     verbose,
#     reference_values
#   )
#
#   reduction.key <- Seurat::Key(reduction.save, quiet = TRUE)
#   rownames(harmonyEmbed) <- rownames(embedding)
#   colnames(harmonyEmbed) <- paste0(reduction.key, seq_len(ncol(harmonyEmbed)))
#
#   object[[reduction.save]] <- Seurat::CreateDimReducObject(
#     embeddings = harmonyEmbed,
#     stdev = as.numeric(apply(harmonyEmbed, 2, stats::sd)),
#     assay = Seurat::DefaultAssay(object = object[[reduction]]),
#     key = reduction.key
#   )
#   if (project.dim) {
#     object <- Seurat::ProjectDim(
#       object,
#       reduction = reduction.save,
#       overwrite = TRUE,
#       verbose = FALSE
#     )
#   }
#   return(object)
# }
data <- panels[[1]]
metadata_list <- list()
for(x in 1:length(panels)){
if(x != 1){
data <- merge(data, panels[[x]], merge.dr = "pca")
}
# for(y in 1:ncol(panels[[x]]))
#   metadata_list <- append(metadata_list, names(panels)[x])
# browser()
#metadata_list <- c(metadata_list, rep(names(panels)[x], ncol(panels[[x]])))
}
metadata_list <- c(rep("jurkrat", 478), rep("t293", 589), rep("5050", 589))
browser()
data$celltype <- metadata_list
harmonizedData <- data %>%
RunHarmony(group.by = "celltype", plot_convergence = TRUE, reduction = "pca")
p1 <- DimPlot(object = harmonizedData, reduction = "harmony", pt.size = .1, group.by = "celltype")
data <- panels[[1]]
metadata_list <- NA
for(x in 1:length(panels)){
if(x != 1){
data <- merge(data, panels[[x]], merge.dr = "pca")
}
# for(y in 1:ncol(panels[[x]]))
#   metadata_list <- append(metadata_list, names(panels)[x])
# browser()
metadata_list <- c(metadata_list, rep(names(panels)[x], ncol(panels[[x]])))
}
browser()
metadata_list[1]
metadata_list[2]
data$celltype <- metadata_list
data <- panels[[1]]
for(x in 1:length(panels)){
if(x != 1){
data <- merge(data, panels[[x]], merge.dr = "pca")
}
# for(y in 1:ncol(panels[[x]]))
#   metadata_list <- append(metadata_list, names(panels)[x])
# browser()
metadata_list <- c(metadata_list, rep(names(panels)[x], ncol(panels[[x]])))
}
browser()
metadata_list
data$celltype <- metadata_list
metadata_list
data <- panels[[1]]
metadata_list <- NULL
for(x in 1:length(panels)){
if(x != 1){
data <- merge(data, panels[[x]], merge.dr = "pca")
}
# for(y in 1:ncol(panels[[x]]))
#   metadata_list <- append(metadata_list, names(panels)[x])
# browser()
metadata_list <- c(metadata_list, rep(names(panels)[x], ncol(panels[[x]])))
}
browser()
metadata_list[1]
length(metadata_list)
data$celltype <- metadata_list
harmonizedData <- data %>%
RunHarmony(group.by = "celltype", plot_convergence = TRUE, reduction = "pca")
p1 <- DimPlot(object = harmonizedData, reduction = "harmony", pt.size = .1, group.by = "celltype")
data <- panels[[1]]
metadata_list <- NULL
for(x in 1:length(panels)){
if(x != 1){
data <- merge(data, panels[[x]], merge.dr = "pca")
}
# for(y in 1:ncol(panels[[x]]))
#   metadata_list <- append(metadata_list, names(panels)[x])
# browser()
metadata_list <- c(metadata_list, rep(names(panels)[x], ncol(panels[[x]])))
}
browser()
data$celltype <- metadata_list
harmonizedData <- data %>%
RunHarmony(group.by = "celltype", plot_convergence = TRUE, reduction = "pca")
